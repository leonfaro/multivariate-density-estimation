{
    "type": [
        0,
        1,
        0,
        1,
        0,
        1,
        2,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        2,
        0,
        1,
        0,
        1,
        0,
        1,
        2,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        2,
        2,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        2,
        0,
        1,
        2,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        2,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        2,
        0,
        1,
        0,
        1,
        0,
        1,
        2,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        2,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        2
    ],
    "data": [
        "> ",
        "# ---- 1. Pakete installieren und laden ----",
        "> ",
        "install.packages(c(\"benchden\", \"np\", \"ks\", \"hdrcde\", \"kdensity\", \"kedd\", \"lpdensity\",",
        "+ ",
        "                   \"ggplot2\", \"gridExtra\", \"viridis\", \"reshape2\", \"tram\", \"party\"))",
        "Error in install.packages : Updating loaded packages\n",
        "> ",
        "",
        "> ",
        "# Lade Pakete",
        "> ",
        "library(benchden)",
        "> ",
        "library(np)",
        "> ",
        "library(ks)",
        "> ",
        "library(hdrcde)",
        "> ",
        "library(kdensity)",
        "> ",
        "library(kedd)",
        "> ",
        "library(lpdensity)",
        "> ",
        "library(ggplot2)",
        "> ",
        "library(gridExtra)",
        "> ",
        "library(viridis)",
        "> ",
        "library(reshape2)",
        "> ",
        "library(tram)        # Für Transformation Models",
        "> ",
        "library(party)       # Für Conditional Inference Trees/Forests",
        "> ",
        "",
        "> ",
        "# ---- 2. Exploration der verfügbaren benchden Verteilungen ----",
        "> ",
        "# Zeige alle verfügbaren Verteilungen in benchden",
        "> ",
        "cat(\"Verfügbare Verteilungen in benchden:\\n\")",
        "Verfügbare Verteilungen in benchden:\n",
        "> ",
        "for(i in 1:28) {",
        "+ ",
        "  cat(sprintf(\"%2d: %s\\n\", i, nberdev(i)))",
        "+ ",
        "}",
        " 1: uniform\n 2: exponential\n 3: Maxwell\n 4: double exponential\n 5: logistic\n 6: Cauchy\n 7: extreme value\n 8: infinite peak\n 9: Pareto\n10: symmetric Pareto\n11: normal\n12: lognormal\n13: uniform scale mixture\n14: Matterhorn\n15: logarithmic peak\n16: isosceles triangle\n17: beta (2,2)\n18: chi-square (1)\n19: normal cubed\n20: inverse exponential\n21: Marronite\n22: skewed bimodal\n23: claw\n24: smooth comb\n25: caliper\n26: trimodal uniform\n27: sawtooth\n28: bilogarithmic peak\n",
        "> ",
        "",
        "> ",
        "# ---- 3. Datengenerierung und explorative Analyse ----",
        "> ",
        "n <- 1000",
        "> ",
        "set.seed(123)",
        "> ",
        "# Generiere Daten aus verschiedenen interessanten Verteilungen",
        "> ",
        "verteilungen <- c(22, 23, 24, 25, 26, 27)  # Interessante Verteilungen",
        "> ",
        "namen <- sapply(verteilungen, nberdev)",
        "> ",
        "daten <- list()",
        "> ",
        "# Generiere Daten für jede Verteilung",
        "> ",
        "for(i in seq_along(verteilungen)) {",
        "+ ",
        "  daten[[i]] <- rberdev(n, verteilungen[i])",
        "+ ",
        "}",
        "> ",
        "",
        "> ",
        "# ---- 4. Explorative Datenanalyse ----",
        "> ",
        "# 4.1 Univariate Statistiken für jede Verteilung",
        "> ",
        "stats <- data.frame(",
        "+ ",
        "  Verteilung = namen,",
        "+ ",
        "  Minimum = sapply(daten, min),",
        "+ ",
        "  Maximum = sapply(daten, max),",
        "+ ",
        "  Mittelwert = sapply(daten, mean),",
        "+ ",
        "  Median = sapply(daten, median),",
        "+ ",
        "  SD = sapply(daten, sd),",
        "+ ",
        "  Schiefe = sapply(daten, function(x) mean((x-mean(x))^3)/sd(x)^3),",
        "+ ",
        "  Kurtosis = sapply(daten, function(x) mean((x-mean(x))^4)/sd(x)^4)",
        "+ ",
        ")",
        "> ",
        "print(stats)",
        "        Verteilung    Minimum   Maximum  Mittelwert     Median         SD      Schiefe\n1   skewed bimodal  -2.809775  3.184044  0.37889314  0.4115223  1.1038551 -0.281916223\n2             claw  -2.848547  3.022104 -0.04648538 -0.0469283  0.8420542  0.017194734\n3      smooth comb  -2.836528  2.984986 -0.05490316 -0.5923929  1.6249474  0.289245913\n4          caliper  -1.073356  1.006745 -0.00997353 -0.1074838  0.4395520 -0.004975007\n5 trimodal uniform -20.099718 20.099018 -0.92795703 -0.1706962 13.8880113  0.065018578",
        "\n6         sawtooth  -9.875589  9.876638  0.02590085 -0.2864085  5.6041220  0.031792491\n  Kurtosis\n1 2.344768\n2 2.879791\n3 1.718237\n4 2.223462\n5 2.080215\n6 1.825331\n",
        "> ",
        "",
        "> ",
        "# 4.2 Visualisierung der einzelnen Verteilungen",
        "> ",
        "# Erstelle ein Grid für die wahren Dichten",
        "> ",
        "x <- seq(-4, 4, length=200)",
        "> ",
        "# Plot für jede Verteilung",
        "> ",
        "par(mfrow=c(2,3))",
        "> ",
        "for(i in seq_along(verteilungen)) {",
        "+ ",
        "  # Histogram der Daten",
        "+ ",
        "  hist(daten[[i]], breaks=30, freq=FALSE,",
        "+ ",
        "       main=paste(\"Verteilung:\", namen[i]),",
        "+ ",
        "       xlab=\"Wert\", ylab=\"Dichte\")",
        "+ ",
        "  ",
        "+ ",
        "  # Überlagere wahre Dichte",
        "+ ",
        "  lines(x, dberdev(x, verteilungen[i]), col=\"red\", lwd=2)",
        "+ ",
        "  ",
        "+ ",
        "  # Füge Kerndichteschätzung hinzu",
        "+ ",
        "  lines(density(daten[[i]]), col=\"blue\", lty=2)",
        "+ ",
        "  ",
        "+ ",
        "  # Legende",
        "+ ",
        "  legend(\"topright\",",
        "+ ",
        "         c(\"True\", \"Estimate\"),",
        "+ ",
        "         col=c(\"red\", \"blue\"),",
        "+ ",
        "         lty=c(1,2))",
        "+ ",
        "}",
        "> ",
        "",
        "> ",
        "# 4.3 HDR Analysis",
        "> ",
        "par(mfrow=c(2,3), mar=c(4,4,3,1))  # Angepasste Margins für besseres Layout",
        "> ",
        "for(i in seq_along(verteilungen)) {",
        "+ ",
        "  # Berechne Kerndichte",
        "+ ",
        "  den <- density(daten[[i]])",
        "+ ",
        "  ",
        "+ ",
        "  # Berechne HDR",
        "+ ",
        "  hdr_result <- hdr.den(daten[[i]], prob=c(50, 90, 95))",
        "+ ",
        "  ",
        "+ ",
        "  # Plot Kerndichte",
        "+ ",
        "  plot(den,",
        "+ ",
        "       main=namen[i],  # Nur den Namen der Verteilung",
        "+ ",
        "       xlab=\"x\",",
        "+ ",
        "       ylab=\"Dichte\",",
        "+ ",
        "       type=\"l\")",
        "+ ",
        "  ",
        "+ ",
        "  # Füge grauen Hintergrund hinzu",
        "+ ",
        "  polygon(den$x, den$y, col=\"gray90\", border=NA)",
        "+ ",
        "  lines(den$x, den$y)",
        "+ ",
        "  ",
        "+ ",
        "  # Füge HDR Markierungen hinzu",
        "+ ",
        "  for(j in 1:nrow(hdr_result$hdr)) {",
        "+ ",
        "    segments(x0=hdr_result$hdr[j,1],",
        "+ ",
        "             x1=hdr_result$hdr[j,2],",
        "+ ",
        "             y0=0,",
        "+ ",
        "             y1=0,",
        "+ ",
        "             col=c(\"red\", \"green\", \"blue\")[j],",
        "+ ",
        "             lwd=3)",
        "+ ",
        "  }",
        "+ ",
        "}",
        "> ",
        "",
        "> ",
        "# 4.4 Bivariate Beziehungen",
        "> ",
        "par(mfrow=c(2,2), mar=c(4,4,3,1))",
        "> ",
        "# Erstelle Scatterplots für verschiedene Kombinationen",
        "> ",
        "plot(daten[[1]], daten[[2]],",
        "+ ",
        "     main=\"Skewed Bimodal vs. Claw\",",
        "+ ",
        "     xlab=namen[1], ylab=namen[2])",
        "> ",
        "plot(daten[[2]], daten[[3]],",
        "+ ",
        "     main=\"Claw vs. Smooth Comb\",",
        "+ ",
        "     xlab=namen[2], ylab=namen[3])",
        "> ",
        "plot(daten[[1]], daten[[3]],",
        "+ ",
        "     main=\"Skewed Bimodal vs. Smooth Comb\",",
        "+ ",
        "     xlab=namen[1], ylab=namen[3])",
        "> ",
        "",
        "> ",
        "# 4.5 Multivariate Analyse",
        "> ",
        "# Erstelle Korrelationsmatrix",
        "> ",
        "cor_matrix <- cor(do.call(cbind, daten[1:3]))",
        "> ",
        "print(\"Korrelationsmatrix der ersten drei Verteilungen:\")",
        "[1] \"Korrelationsmatrix der ersten drei Verteilungen:\"\n",
        "> ",
        "print(cor_matrix)",
        "             [,1]        [,2]         [,3]\n[1,]  1.000000000 -0.02642850  0.009825518\n[2,] -0.026428499  1.00000000 -0.055749564\n[3,]  0.009825518 -0.05574956  1.000000000\n",
        "> ",
        "",
        "> ",
        "# ---- 5. Transformation Forest Ansatz ----",
        "> ",
        "# Erstelle Datensatz für alle Analysen",
        "> ",
        "data_all <- data.frame(",
        "+ ",
        "  y1 = daten[[1]],",
        "+ ",
        "  y2 = daten[[2]],",
        "+ ",
        "  y3 = daten[[3]]",
        "+ ",
        ")",
        "> ",
        "",
        "> ",
        "# 5.1 Schätze die bedingte Dichte p(y1)",
        "> ",
        "tf_model1 <- tram::BoxCox(y1 ~ 1, data = data_all)",
        "> ",
        "",
        "> ",
        "# 5.2 Schätze die bedingte Dichte p(y2|y1)",
        "> ",
        "tf_model2 <- tram::BoxCox(y2 ~ y1, data = data_all)",
        "> ",
        "",
        "> ",
        "# 5.3 Schätze die bedingte Dichte p(y3|y1,y2)",
        "> ",
        "tf_model3 <- tram::BoxCox(y3 ~ y1 + y2, data = data_all)",
        "> ",
        "",
        "> ",
        "# ---- Korrektur: Definiere eval_data vor Verwendung ----",
        "> ",
        "# Erstelle Evaluierungsdatensatz",
        "> ",
        "eval_data <- data_all  # eval_data jetzt definiert",
        "> ",
        "",
        "> ",
        "# Test predict Funktion mit minimalen Beispiel",
        "> ",
        "print(\"Test Basic Prediction:\")",
        "[1] \"Test Basic Prediction:\"\n",
        "> ",
        "# Teste erste Beobachtung",
        "> ",
        "test_pred <- try(",
        "+ ",
        "  predict(tf_model1,",
        "+ ",
        "          newdata = data.frame(y1 = eval_data$y1[1]),",
        "+ ",
        "          type = \"trafo\")",
        "+ ",
        ")",
        "> ",
        "print(test_pred)",
        "         1 \n-0.8162229 \n",
        "> ",
        "",
        "> ",
        "# Teste für gültigen 'type' Parameter",
        "> ",
        "print(\"\\nTest Response Transformation:\")",
        "[1] \"\\nTest Response Transformation:\"\n",
        "> ",
        "resp_trafo <- try(",
        "+ ",
        "  predict(tf_model1,",
        "+ ",
        "          newdata = data.frame(y1 = eval_data$y1[1]),",
        "+ ",
        "          type = \"distribution\")  # 'distribution' statt 'response'",
        "+ ",
        ")",
        "> ",
        "print(resp_trafo)",
        "        1 \n0.2071863 \n",
        "> ",
        "# ---- 6. Vergleich und Evaluation ----",
        "> ",
        "",
        "> ",
        "# Erstelle Evaluierungsdatensatz",
        "> ",
        "eval_data <- data.frame(",
        "+ ",
        "  y1 = daten[[1]],",
        "+ ",
        "  y2 = daten[[2]], ",
        "+ ",
        "  y3 = daten[[3]]",
        "+ ",
        ")",
        "> ",
        "",
        "> ",
        "# Verbesserte Funktion zur Berechnung der bedingten Dichte",
        "> ",
        "get_conditional_density <- function(model, newdata, grid_size=100) {",
        "+ ",
        "  # Finde die Response-Variable",
        "+ ",
        "  response_var <- all.vars(model$call)[1]",
        "+ ",
        "  ",
        "+ ",
        "  # Berechne Range aus den Daten",
        "+ ",
        "  y_range <- range(model.frame(model)[[response_var]])",
        "+ ",
        "  y_grid <- seq(y_range[1], y_range[2], length.out=grid_size)",
        "+ ",
        "  ",
        "+ ",
        "  # Matrix für Dichten",
        "+ ",
        "  densities <- matrix(NA, nrow=nrow(newdata), ncol=length(y_grid))",
        "+ ",
        "  ",
        "+ ",
        "  # Berechne Dichten für jeden Grid-Punkt",
        "+ ",
        "  for(i in 1:nrow(newdata)) {",
        "+ ",
        "    current_data <- newdata[i,, drop=FALSE]",
        "+ ",
        "    densities[i,] <- predict(model, ",
        "+ ",
        "                             newdata=current_data, ",
        "+ ",
        "                             type=\"density\",",
        "+ ",
        "                             q=y_grid)",
        "+ ",
        "  }",
        "+ ",
        "  ",
        "+ ",
        "  # Mittelwert der Dichten",
        "+ ",
        "  return(colMeans(densities))",
        "+ ",
        "}",
        "> ",
        "",
        "> ",
        "# Berechne Log-Likelihood für die Faktorisierung",
        "> ",
        "ll_fact <- try({",
        "+ ",
        "  ll1 <- sum(log(get_conditional_density(tf_model1, ",
        "+ ",
        "                                         data.frame(y1=eval_data$y1))))",
        "+ ",
        "  ll2 <- sum(log(get_conditional_density(tf_model2, ",
        "+ ",
        "                                         eval_data[,c(\"y1\",\"y2\")])))",
        "+ ",
        "  ll3 <- sum(log(get_conditional_density(tf_model3, ",
        "+ ",
        "                                         eval_data)))",
        "+ ",
        "  ll1 + ll2 + ll3",
        "+ ",
        "})",
        "Error: no more error handlers available (recursive errors?); invoking 'abort' restart\n",
        "Error in stopifnot(order > max(c(0, deriv - 1L))) : \n  INTEGER() can only be applied to a 'integer', not a 'unknown type #29'\n",
        "In addition: ",
        "Warning message:\n",
        "In stopifnot(order > max(c(0, deriv - 1L))) :",
        "\n ",
        " type 29 is unimplemented in 'type2char'\n",
        "> ",
        "",
        "> ",
        "# Berechne direkte multivariate Dichten",
        "> ",
        "# np package",
        "> ",
        "np_bw <- npudensbw(eval_data)",
        "\rMultistart 1 of 3 |\nRestarting R session...\n\n"
    ]
}